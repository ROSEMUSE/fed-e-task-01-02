### 函数式编程
+ 对运算过程中的抽象
+ 函数是一等公民（可以作为函数参数，可以作为函数返回值，也可以赋值给变量）
+ 函数作为参数使编程更灵活
+ 高阶函数的意义，抽象可以帮我们屏蔽细节

### 闭包
+ 可以在另一个作用域中调用另一个函数内部函数并访问到该函数到作用域中的成员
+ 函数在执行的时候会放在一个执行栈上当函数执行完毕之后会从执行栈上移除，但是堆上的作用域成员因为被外部引用不能释放，因此内部函数依然可以访问外部函数的成员

### 纯函数：相同的输入永远会得到相同的输出
+ 函数式编程不会保留计算中间的结果，所以变量是不可变的（无状态的）

### 纯函数的好处
+ 可缓存 因为纯函数对相同对输入始终有相同的结果，所以可以把纯函数的结果缓存起来
+ 可测试 纯函数让测试更方便
+ 并行处理 在多线程环境下并行操作并行共享的内存数据可能会出现意外情况，纯函数不需要访问共享的内存数据，所以在并行环境可以任意运行纯函数

### 函数式编程副作用
+ 对于相同的输入永远得到相同的输出，而且没有任何可观察的副作用
+ 副作用让一个函数变得不纯，纯函数的根据相同的输入返回相同的输出，如果函数依赖于外部的状态就无法保证输出的相同，就会带来副作用
+ 副作用来源：配置文件，数据库，获取用户的输入
+ 所有外部交互都会产生副作用，副作用也使得方法通用性下降不适合扩展和可重用性，同时副作用会给程序中带来安全隐患，所以尽可能控制它们在可控制范围内

### 函数柯里华
+  当一个函数有多个参数的时候先传递一部分参数调用它（这部分参数以后永远不会变）
+ 然后当返回一个新的函数接收剩余的参数，返回结果
+ 柯里化可以让我们给一个函数传递较少的参数得到一个已经记住了某些固定参数的新函数
+ 这是一种对函数参数对缓存
+ 让函数变得更灵活，让函数的粒度更小
+ 可以把多元函数转换成一元函数，可以组合使用函数产生强大的功能

### 函数组合
+ 函数组合可以让我们把细粒度的函数组成一个新函数
+ 如果一个函数要经过多个函数处理才能得到最终值，这个时候可以把中间过程的函数合并成一个函数
+ 函数组合默认是从右到左执行 fn = compose(f1, f2, f3) b = fn(a)
+ 结合律：compose(compose(f,g),h) == compose(f,compose(g,h))

### lodash/fp: lodash的fp模块提供了实用的对函数式编程友好的方法（函数式编程 functional programming）
+ 柯里化的 lodash ，函数优先，数据置后

### Point Free:不使用所要处理的值，只合成运算过程
+ 我们可以把数据处理的过程定义成与数据无关的合成运算，不需要用到代表数据的那个参数，只要把简单的运算步骤合成到一起，在使用这种模式之前我们需要定义一些辅助的基本运算函数
+ 不需要指明处理的数据
+ 只需要合成运算过程
+ 需要定义一些辅助的基本运算函数

### Functor（函子）
+ 容器：包含值和值的变形关系（这个关系变形就是函数）
+ 函子：函子是一个普通对象（在其他语言中，可能是一个类），它实现了 map 函数，在遍历每个对象值的时候生成一个新对象。
+ 函数式编程的运算不直接操作值，而是由函子完成
+ 函子就是一个实现了map契约的对象
+ 我们可以把函子想象成一个盒子，这个盒子里封装了一个值
+ 想要处理盒子中的值，我们需要给盒子map方法传递一个处理值的函数（纯函数），由这个函数来对值进行处理
+ 最终map方法返回一个包含新值的盒子
+ 函数式编程一般约定，函子有一个 of 方法，用来生成新的容器。（就是帮我们 new 了一个对象出来）

### MayBe函子
+ 在编程过程中可能会遇到很多错误，需要对错误进行相应的处理
+ MayBe函子的作用就是可以对外部的空值情况做处理（控制副作用在允许的范围）

### Either函子
+ Either俩者中的任何一个，类似if...else...的处理
+ 异常会让函数变得不纯，Either函子可以用来做异常处理

### IO函子
+ IO函子中的_value是一个函数，这里把函数作为值来处理
+ IO函子可以把不纯的动作存储到 _value 中，延迟执行这个不纯到操作（惰性执行），包装当前的操作为纯操作
+ 把不纯的操作交给调用者处理

### Task异步执行
+ 异步执行任务过于辅助，我们使用foiktable中到Task来演示
+ fooltake 标准到函数式编程库
+ 和lodash/remda 不同到是，他没有提供很多功能函数
+ 只提供来一些函数式处理到操作，例如：compose, curry等，一些函子 Task, Either, MayBe等

### Pointed函子
+ 实现了of 静态方法的函子
+ of 方法是为了避免使用new来创建对象，更深层的含义是Of方法用来把值放到上下文Context(把值放到容器中，使用map来处理)

### Monad 函子是可以变扁的 Pointed函子 IO（IO(x))
+ 一个函子如果具有join 和of俩个方法并遵守一些定律就是一个Monad
+ 解决函子嵌套问题

### 内存管理
+ 内存：由可读写单元组成，表示一片可操作的空间
+ 管理： 人为的去操作一片空间的申请、使用和释放
+ 内存管理：开发者主动申请空间、使用空间、释放空间
+ 管理流程：申请-使用-释放

### JavaScript 中的垃圾
+ JavaScript 中内存管理是自动的
+ 对象不再被引用时是垃圾
+ 对象不能从根上访问到时是垃圾 

### JavaScript可达对象
+ 可以访问到对象就是可达对象（引用、作用域链）
+ 可达的标准就是从根出发是否能够被找到
+ JavaScript中的根就可以理解为全局变量对象

### GC算法介绍
+ GC是一种机制，垃圾回收器完成具体的工作
+ 工作的内容就是查找垃圾释放空间、回收空间
+ 算法就是工作时查找和回收所遵循的规则
+ 常见GC算法：引用计数、标记清除、标记整理、分代回收

### 引用计数算法
+ 核心思想：设置引用数，判断当前引用数是否为0
+ 引用计数器
+ 引用关系改变时修改引用数字
+ 引用数字为0时立即回收

### 引用计数算法优点
+ 发现垃圾时立即回收
+ 最大限度减少程序暂停

### 引用计数算法缺点
+ 无法回收循环引用的对象
+ 时间开销大
+ 资源消耗大

### 标记清除算法实现原理
+ 核心思想：分标记和清除俩个阶段完成
+ 遍历所有对象找标记活动对象
+ 遍历所有对象清除没有标记对象

### 标记清除算法优缺点
+ 可以回收循环引用对象
+ 空间的问题，标记清除以后会产生大量不连续的空间碎片，空间碎片太多可能会导致程序运行过程需要分配较大的对象时候，无法找到足够连续内存而不得不提前触发一次垃圾收集。
+ 不会立即回收垃圾对象

### 标记整理算法原理
+ 标记整理可以看做是标记清除的增强
+ 标记阶段的操作和标记清除一致
+ 清除阶段会先执行整理，移动对象位置
+ 减少碎片化空间
+ 不会立即回收垃圾对象

### V8引擎
+ V8是一款主流js引擎
+ 采用即时编译
+ 内存设限
+ 采用分代回收的思想
+ 内存分为新生代、老生代
+ 针对不同对象采用不同算法
+ V8内存空间一分为二（新生代，老年代）
+ 小空间用于存储新生代对象（32M|16M)+ 新生代指的是存活时间较短的对象
+ 回收过程：采用复制算法+标记整理，使用空间为from，空闲空间为To(相等大小)， 活动对象存储于From空间，标记整理后将活动对象拷贝到To，From与to交换空间完成释放
+ 新生代回收细节说明：拷贝过程中可能出现晋升（就是将新生代对象移动至老生代：一轮GC还存活的新生代需要晋升，To空间的使用率超过25%）
+ 老年对象就是指存活时间较长的对象（如 闭包）
+ 老年对象回收：标记清除、标记整理、增量标记算法
+ 首先使用标记清除完成垃圾空间的回收
+ 采用标记整理进行空间优化
+ 采用增量标记进行效率优化
+ 新生代区域垃圾回收使用空间换时间
+ 老生代区域垃圾回收不适合复制算法

### 增量标记算法如何优化垃圾回收：
+ 将当前一整段垃圾回收分成多段执行，在程序运行中穿插进行，分阶段进行遍历对象标记，最后标记完成执行垃圾回收操作，继续执行程序运行，极大的缩短GC算法暂停时间

### 监控内存
+ 内存泄漏：内存使用持续升高
+ 内存膨胀：在多数设备上都存在性能问题
+ 频繁垃圾回收：通过内存变化图形进行分析
+ 浏览器任务管理器
+ Timeline时序图记录
+ 堆快照查找分离dom
+ 判断是否存在频繁的垃圾回收

### 代码优化
+ 慎用全局变量：全局变量定义在全局执行上下文，是所有作用域链的顶端
+ 全局执行上下文一值存在于上下文执行栈，直到程序退出
+ 如果某个局部作用域出现了同名变量则会这笔或污染全局
+ 缓存全局变量
+ 通过原型对象添加附加方法
+ 避开闭包陷阱（使用重新定义函数使用闭包）
+ 避免属性访问方法使用
+ for循环优化（减少循环体访问）
+ 采用最优循环方式（forEach>优化的for>for in)
+ 文档碎片化优化节点添加（DocumentFragment，文档片段接口，不是真实 DOM 树的一部分，它的变化不会触发 DOM 树的重新渲染，且不会导致性能等问题。）
+ 克隆优化节点操作（cloneNode)
+ 直接量替换new Object (var a = [])